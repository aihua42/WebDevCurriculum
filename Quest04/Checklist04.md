# Quest 04. OOP의 기본

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.

## Topics
* 객체지향 프로그래밍
  * 프로토타입 기반 객체지향 프로그래밍
  * 자바스크립트 클래스
    * 생성자
    * 멤버 함수
    * 멤버 변수
  * 정보의 은폐
  * 다형성
* 코드의 재사용

## Checklist
* ### 객체지향 프로그래밍은 무엇일까요?    
  객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나, 즉 절차지향 프로그래밍(procedural programming)과는 다른, 여러개의 독립된 단위인 '객체'들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 서로 메세지를 주고받고, 데이터를 처리할수 있다. 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.   
  (출처: [위키백과](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))
  * #### `#`로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요?
    `#`으로 시작하는 private field는 클래스 내부에서만 접근이 가능하다. 클래스 외부에서 보이지 않도록 정의하였으므로 클래스가 버전업 되면서 내부 구현이 바뀌더라도 클래스 사용자입장에서는 아무런 영향을 받지 않도록 할수 있다. 

    캡슐화(encapsulation)란 데이터(속성)과 데이터를 처리하는 함수를 하나로 묶는것이다. 객체 외부에서 내부 정보를 접근하거나 조작할수 없고, 외부에서 접근할수 있도록 정의된 operation(getter/setter)를 통해서만 관련 데이터에 접근할수 있다. 이런 정보 은닉(information hiding)은 캡슐화의 가장 중요한 장점이다. 
    >1. 내부에 직접 접근할수 없어서 객체에 포함된 정보의 손상과 오용을 막을 수 있다.
    >2. 데이터가 바뀌어도 다른 객체에 영향을 주지 않아 독립성이 유지된다.
    >3. 처리된 결과만 사용하므로 객체의 이식성이 좋다.

    <br>
    자바스크립트에서 closure를 사용하여 캡슐화와 정보 은닉을 실현할수 있다. 클로저란 어떤 함수가 본인이 선언된 주변 환경을 지속적으로 기억하는 것을 의미한다. 어디에서 선언되었고, 어디에서 실행되었는지는 중요하지 않다. Lexical scoping에 의해 해당 함수가 선언되어 있을때의 환경의 영향만 받는다.        
       
    >Lexical scoping은 함수를 어디에 선언했는지에 따라 스코프가 결정되는 것을 말한다.
   
    ```js
    function createUser(name, phoneNum) {
      let _phoneNum = phoneNum;

      const user = {
        name,

        get phoneNum() {
          return _phoneNum;
        },

        set phoneNum(number) {
          _phoneNum = number;
        }
      };

      return user;
    }
    const user1 = createUser('Ava', '01012345678');
    console.log(user1.phoneNum);  // 01012345678
    console.log(user1._phoneNum); // undefined
    ```
  * #### 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?
    다형성(polymorphism)은 특정 기능을 선언(설계)부분과 구현(동작)부분으로 분리한 후 구현 부분을 다양한 방법으로 만들어 선택하여 사용할수 있게 하는 기능이다. 즉 하나의 타입에 여러 객체를 대입할수 있는 성질같은것이다.     
    자바스크립트에서 다형성을 구현하는 방법에는 '오버라이딩'이 있다. 상속을 통해 부모 클래스의 메소드를 자식 클래스가 재정의(오버라이딩)해서, 사용할때 같은 이름의 메소드를 사용하더라도 제각각 하는 기능이 달라지게 한다.       

    상속을 통한 다형성을 활용하면 기능 변경 및 확장을 함과 동시에 중복되는 코드를 제거할수 있어 코드의 구조를 정리하는데 유용하다.
  * #### 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?
    'IS A' 관계. 상속(inheritance)이란 부모 객체가 자식 객체에게 자신의 property와 method를 물려주는것을 말한다. 백화점 일반 고객과 VIP 고객의 관계와 같은 것이다.    
    * 상속을 사용하게 되면 반복적인 코드를 줄일수 있다.
    * 부모 클래스의 기능들을 수정하거나 확장해서 사용할수 있다.
    * 개발 시간이 단축된다.   
    
    하지만 주의해야 할 점도 존재한다.
    * 상위 클래스에서 뭔가를 수정하게 되면 하위 클래스들에게도 영향을 주게 된다.
    * 상속구조가 복잡해지면 부모 클래스의 변화가 자식 클래스에 주는 영향을 예측하기 어려워진다.
    * 따라서 디버깅이 어려워지고 유지보수에 안 좋을 수 있다.
  * #### OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?
    'HAS A' 관계. 기존 클래스가 새로운 클래스의 구성요소로 쓰이는것, 즉 클래스안에 다른 클래스를 넣는 것을 의미한다. 상속 대신 합성을 하게 되면 아래와 같은 좋은 점들이 있다.
    1. 결합도를 낮춤으로써 객체사이의 의존 정도를 낮춰 관계는 유연해지고 수정에 용이해진다.
    2. 불필요한 기능의 상속을 피할수 있고, 부모 클래스의 결함도 피할수 있다.
    3. 캡슐화를 위반하는것을 피할수 있다. 상속을 통해 부모 클래스의 메소드를 오버라이딩할 때, 외부에서 사용하도록 노출한 부모 클래스의 메소드를 자식 클래스가 상속받고 똑같이 사용하게 되면, 내부에서 자체적으로 계속 호출하는 메소드같은 경우에는 원하는 결과를 얻을수 없게 된다. 클래스를 상속이 아닌 내부 필드로 바꾸어주면 이 문제를 해결할수 있다.
    4. 상속은 다중 상속이 불가능하다. 상속이 필요한 해당 클래스가 이미 다른 클래스를 상속중이라면 문제가 될수 있다. 합성을 이런 단일 상속 한계를 어느정도 해소해준다. 클래스 객체 기능이 필요한 만큼 필드에 정의해 두어 사용하면 된다.
* ### 자바스크립트의 클래스는 어떻게 정의할까요?
  자바스크립트는 ES6부터는 class를 도입했다. 
  ```js
  class Student {
    static teacher = 'Ava';  // 고유의 값
    #address = 'GangNam, Seoul';  // priviate field
    // 속성 정의
    constructor(name, level, score) {
      this.name = name;
      this.level = level;
      this.score = score;
    }

    // 메소드 정의
    greeting() {
      console.log(`The score of student ${this.name} in level ${this.level} is ${this.score}.`);
    }
  }
  const student1 = new Student('Jane', 9, 88);
  student1.greeting();
  ```
  `class` operator를 사용하여 클래스를 정의하고, `new` operator를 사용하여 instance를 생성한다.<br>
  <br>

  ```js
  // 상속
  class NewStudent extends Student {
    constructor (name, level, score, joinDate) { // constructor에 다른걸 추가하고 싶을 때
      super(name, level, score);  //  부모 클래스의 constructor
      this.joinDate = joinDate;
    }
    greeting() { // method에 다른걸 추가하고 싶을 때
      super.greeting();  // 부모 클래스의 메소드
      console.log('This student is new face!');
    }
  }
  ```
  `extends` operator로 클래스를 상속받고, `super` operator로 부모 클래스의 메소드를 가져온다(가져오고 싶으면).
  * #### 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?
    `Prototype`이란 이론은 비트겐슈타인의 의미사용이론(맥락, context, 사용에 의해 의미가 결정된다는 이론)과 가족 유사성(resemblance, 가족 모두 공유하는 공통 속성이 없지만 높은 유사성이 있다)에서 나왔는데, 객체는 '정의'로부터 분류되는것이 아니라 '가장 좋은 보기'로부터 범주화된다는 것이다. __분류를 우선시 하지 않고 <u>생성된 객체 위주</u> (이미 존재하는 사물을 통해 범주화)로 유사성을 정의__ 하고 __설계, 쓰임새는 맥락__ 에 의해 평가되는 이러한 프로토타입 이론은 그대로 프로토타입 기반 객체지향 프로그래밍 언어를 통해 구현되었다.      
    >여기서 말하는 '분류'란 아리스토텔레스의 '분류'(classification)라는 개념에서 따온건데, __개체의 속성이 동일한 경우__ 개체 그룹이 같은 범주에 속하고 범주는 정의와 구별의 합이라는것이다. 이는 전통적인 `class` 기반 객체 지향 프로그래밍의 아이디어-일반화와 일치하다. 여기서 속성은 클래스의 property가 되고, property가 유사한 객체가 있다면 일반화 과정을 통해 클래스로 추상화된다.          

    (출처: [Medium](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42))  

    따라서 프로토타입 기반의 객체지향 프로그래밍은 원형을 이용하여 새로운 객체를 만들어내고, 이렇게 새롭게 만들어진 객체는 또 다른 원형이 되어 다른 새로운 객체를 만들어내는 구조로 객체를 확장한다. 이때 원형을 선언할때 만들어진 속성들은 그대로 하위 객체들에 상속되는데 이는 class 기반의 객체지향 프로그래밍이랑 비슷하나, 원형 선언과 동시에 만들어진 Prototype Object는 하위 객체들과 공유되는 형태이다. 때문에 하위 객체가 새로운 원형이 되면, 새로운 Prototype Object가 생겨나고 그의 하위 객체들과 공유하게 된다. 프로토타입은 이런식으로 객체의 동작 방식들을 복제한다. 그리고 Prototype Object를 수정하게 되면 그걸 가리키고 있는 객체들에 다 영향주게 된다.
    >원형은 `prototype` property가 Prototype Object를 가리키고 있고, 새로운 객체들은 `__proto__` property가 Prototype Object를 가리키게 된다.

    <br>

    아래는 위키백과에서 정의한 프로토타입 기반 프로그래밍이다.     

    >프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, `객체`를 원형(原型, prototype)으로 하여, 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다. 프로토타입 기반 프로그래밍은 class-less, prototype-oriented 혹은 instance-based 프로그래밍이라고도 한다.    
    (출처: [위키백과](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))


  * #### 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?
    프로토타입 기반의 객체지향에서는 함수의 선언이 class와 동일한 개념으로 작동했다. 함수 기반의 클래스는 생성자 없이 객체를 생성하고, `constructor`, `prototype`이라는 property와 `hasOwnProperty()`, `toString()`, `isPrototypeOf()`라는 메소드들이 있다.  

    그러다 ES6에 class가 도입되면서 constructor 생성자를 통해, 함수 기반의 constructor와 prototype 구조를 좀 더 간단하게 표현할수 있게 되었다. 하지만 함수 기반의 선언과 `class` 기반의 선언은 중요한 차이점이 있는데, 그것은 함수의 경우 정의하기 전에 호출할수 있지만, class는 반드시 정의한 뒤에 사용할수 있다. 또한 class 문법 안에 있는 코드는 항상 `use strict`명령 없이도 항상 strict mode로 실행되는 반면, 함수기반은 넣어줘야 strict mode로 실행된다. 이 특징은 this값의 자동 바인딩에 영향준다.

    하지만 어찌 되었든 자바스크립트는 프로토타입 기반의 객체지향 언어이기 때문에, 본질을 흐려서는 안된다. 객체의 확장은 prototype을 통해 이루어져야 하고 class는 문법만 추가된, syntactic sugar 정도로만 생각할 필요가 있다.
    